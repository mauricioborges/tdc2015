<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

        <title>Put that Groovy on it: introduzindo testes em código Java legado usando Groovy</title>

		<meta name="description" content="Código legado Java pode ser testado, e nesta palestra vamos ver exemplos de técnicas de escrita de testes usando Groovy.">
		<meta name="author" content="Maurício Borges Silva">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h4>TDC Porto Alegre 2015 - Trilha Java</h4>
                    <h3>Put that Groovy on it: introduzindo testes em código Java legado usando Groovy</h3>
					<p>
                    <small><a href="http://github.com/mauricioborges">github.com/mauricioborges</a> / <a href="http://twitter.com/silvamauriciob">@silvamauriciob</a></small>
					</p>
				</section>
				<section data-markdown>
                    ## Agenda
                    
                    * Legado. Quem nunca?
                    * Um exemplo nada real
                    * Passo a passo
                    * Errata
                    * Porque Groovy?
				</section>
				<section data-markdown>
                    ## Legado. Quem nunca?
                    
                    > "There's no guarantee, It's not up to me, We can only see this is my legacy"
                    >
                    > Eminem, Legacy
                    Note:
                    é feio. é ruim. é cansativo. it's only legacy code, but I hate it!
				</section>
				<section data-markdown>
                    > "**Code without tests is bad code**. It doesn't matter how well written it is; it doesn't matter how pretty or object-oriented or well-encapsulated it is."
                    >
                    > Michael C. Feathers, Working Effectively with Legacy Code
                    
                    Note: 
                    Como bem sumarizou o Feathers no Working effectively with legacy code, código sem testes é ruim. Sem testes, não tem como mudar o código com confiança. E como é fácil fazer código legado: é um protótipo que vira produção sem um refactoring sequer, é a mudança que precisa ser entregue daqui a pouco ou haverá muita perda (será?). Sempre há um motivo
				</section>
				<section data-markdown>
                    > "Se vivermos durante muito tempo, descobrimos que todas as vitórias, um dia, se transformam em derrotas."
                    >
                    > Simone de Beauvoir (pelo menos foi o que a internet disse)
                    
                    Note: 
                    A entrega de hoje é o bug de amanhã. Quando causamos um débito, geramos um legado pro futuro, estamos colocando na conta do futuro a decisão apressada do agora. Nada novo até aqui...e vou parar com citações
				</section>
				<section>
                    <section data-markdown># Um exemplo nada real</section>
                    <section data-markdown>
                        Uma empresa nada real pediu para construir um sistema nada plausível para cadastro de produtos para seu cenário completamente diferente de tudo que existe no resto do mundo. Ou pelo menos foi isso que alguém se convenceu a acreditar.
                    </section>
                    <section data-markdown>
                        O sistema precisava ficar pronto bem rápido, então alguns débitos foram gerados. Atrasou alguns meses a entrega no fim das contas, mas foi uma "vitória".
                    </section>
                    <section data-markdown>
                        Então agora o sistema está rodando em produção, tudo está tranquilo, mas vai ser necessária uma alteração...zinha
                    </section>
				</section>
				<section>
                    <section data-markdown>
                        # Requisito:
                        Adicionar um cálculo no código para adicionar 0.20% ao preço informado antes de gravar no banco
                        Note:
                        Aqui eu mostro como funciona o glorioso sistema, e como tá o código hoje: mostrar a classe main, a classe ProdutoView o o Controller
                    </section>
                    <section data-markdown>
                        # Ou seja:

                        |preço informado|preço salvo|
                        |---------------|-----------|
                        |R$ 100         |R$ 100,20  |
                        |R$ 42          |R$ 42,084  |
                        |R$ 0           |R$ 0       |

                        Note:
                        Aqui eu mostro como funciona o glorioso sistema, e como tá o código hoje: mostrar a classe main, a classe ProdutoView o o Controller
                    </section>
				</section>
				<section>
                    <h1>Como funciona a aplicação hoje?</h1>
                    <a href="chrome-extension://pnhechapfaindjhompbnflcldabbghjo/html/nassh.html#profile-id:b0d8" target="_blank">assim!</a>
				</section>
				<section>
                    <section data-markdown>
                    # Passo a passo
                    
                    > Fortemente baseado na bibliografia de Feathers

                    Note:
                    A inclusão ou não de dependências é um ponto importante. Com Spock + uso de interfaces fica apenas o spock, sem "escolha" de frameworks adicionais. Note como é bom entender o código com caracterização. Ainda que eu encontre um possível problema de design (DAO com todas as regras de negócio), eu pelo menos consegui escrever um monte de testes para uma parte do código
                    </section>

                    <section data-markdown>preparar um script de build que não altere o build do projeto atual</section>
<section><h2>build.gradle</h2><pre  data-trim contenteditable class="groovy"><code>
apply plugin: 'groovy'
apply plugin: 'java'
apply plugin: 'idea'

repositories {
    jcenter()
}

dependencies {
    testCompile 'org.codehaus.groovy:groovy-all:2.4.4'
    testCompile 'junit:junit:4.12'
    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'
    testCompile 'org.hamcrest:hamcrest-junit:2.0.0.0'
    testCompile ('com.athaydes:spock-reports:1.2.7'){
        transitive = false
    }
    testCompile "org.mockito:mockito-core:1.+"
    testCompile "cglib:cglib-nodep:2.2"

    //dependencies from legacy project
    testCompile files('.lib/sqlite-jdbc-3.8.11.1.jar')
    testCompile files('out/production/legacy-code')
}
// importing legacy build script into this script
ant.importBuild('legacy-code.xml'){ antTargetName ->
    'a-' + antTargetName
}
// add legacy basic build to compile workflow
compileJava.dependsOn 'a-all'

// changed sourceSets to avoid path collision (due to non-standard legacy config)
sourceSets {
    test {
        java {
            srcDir 'test/java'
        }
        groovy {
            srcDir 'test/groovy'
        }
    }
}
</code></pre></section>

                    <section data-markdown>
                        escrever um teste que instancie a classe onde você (acha que) deve alterar
                        Note:
                        aqui tu pode abrir um arquivo java e criar uma classe para testar. e depois um groovy. Colas em cola.txt
                </section>
<section>
<h2>Java</h2>
<pre  data-trim contenteditable class="java"><code>
import org.junit.Test;
import tdc2015.legacy.produto.ProdutoController;

import static org.junit.Assert.assertNotNull;

public class ProdutoControllerJavaTesting {

    @Test
    public void testIfYouCanCreateAProdutoControllerInstance() {
        assertNotNull(new ProdutoController(null));
    }
}
</code></pre>
</section>
<section>
<h2>Groovy</h2>
<pre  data-trim contenteditable class="groovy"><code>
import tdc2015.legacy.produto.ProdutoController

class ProdutoControllerGroovyTesting extends GroovyTestCase {

    void "test if it's possible to create a ProdutoController instance"() {
        assert new ProdutoController(null) != null
    }
}
</code></pre>
<h2>Groovy+Spock</h2>
<pre  data-trim contenteditable class="groovy"><code>
import spock.lang.Specification
import tdc2015.legacy.produto.ProdutoController

class ProdutoControllerSpockTest extends Specification {

    def "should be able to create a controller's instance when needed"() {
        expect:
        new ProdutoController(null) != null
    }
}
</code></pre>
<aside class="notes">
Notar as diferenças: o nome do metodo pode ser um string. Groovy tem já uma classe de teste embutida que herda de junit, permitindo escrever testes sem adicionar bibliotecas novas. Notar que tem menos palavras no teste em groovy. O teste em groovy tem menos elementos que não interessam no momento para alguém que está brincando com um código que não conhece direito e/ou tem sérios problemas estruturais. Mostrar as criações de testes que eu fiz em spock e java, lá nos *aracterizando*
</aside>
</section>
                    <section data-markdown>CUIDADO: se precisar fazer alterações mínimas, não intrusivas e preferencialmente daquelas que podem ser feitas automaticamente pela IDE, faça. Com calma...</section>
<section>
<pre data-trim contenteditable class="java"><code>
package tdc2015.legacy.produto;

import java.util.List;

public class ProdutoController {

    private ProdutoDAO dao;

    //WARNING!! construtor para testes
    public ProdutoController(ProdutoDAO dao) {
        this.dao = dao;
    }

    //construtor original
    public ProdutoController() {
        this.dao = new ProdutoDAO(Env.CONNECTION_DATA);
    }
// ...
}
</code></pre>
</section>
                    <section data-markdown>escrever testes que caracterizem o local que eu devo alterar</section>
<section>
<pre data-trim contenteditable class="java"><code>
import org.junit.Test;
import tdc2015.legacy.produto.ProdutoController;
import tdc2015.legacy.produto.ProdutoDAO;
import tdc2015.legacy.produto.ProdutoException;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

public class ProdutoControllerJavaTesting {

    @Test
    public void testIfYouCanCreateAProdutoControllerInstance() {
        assertThat(new ProdutoController(null), is(not(nullValue())));
    }

    @Test
    public void testIfYouCanCreateAProdutoControllerInstanceWithAMockedDAO() {
        ProdutoDAO mockedDAO = mock(ProdutoDAO.class);
        new ProdutoController(mockedDAO).listar();
        verify(mockedDAO, times(1)).list();
    }

    @Test(expected = ArrayIndexOutOfBoundsException.class)
    public void testCreateParametersBehaviour1() throws ProdutoException {
        ProdutoDAO mockedDAO = mock(ProdutoDAO.class);
        new ProdutoController(mockedDAO).criar("");
    }

    @Test
    public void testCreateParametersBehaviour2() throws ProdutoException {
        ProdutoDAO mockedDAO = mock(ProdutoDAO.class);
        new ProdutoController(mockedDAO).criar("a;b;c;d;e");
        verify(mockedDAO, times(1)).buscaPorEAN("e");
        verify(mockedDAO, times(1)).buscaPorNome("a");
        verify(mockedDAO, times(1)).createProduct("a;b;c;d;e");
        verify(mockedDAO, times(1)).getProduct(anyInt());

    }
}
</code></pre>
</section>
<section>
<pre data-trim contenteditable class="groovy"><code>
import spock.lang.Specification
import tdc2015.legacy.produto.Produto
import tdc2015.legacy.produto.ProdutoController
import tdc2015.legacy.produto.ProdutoDAO

class ProdutoControllerSpockTesting extends Specification {

    def "should be able to create a controller's instance when needed"() {
        expect:
        new ProdutoController(null) != null
    }

    def "should be able to create a controller's instance using a mocked DAO"() {
        expect:
        new ProdutoController(Mock(ProdutoDAO)) != null
    }

    def "should be able to stub dao when calling criar()"() {
        given: "a stubbed DAO which always return ok"
        def mockedDAO = Stub(ProdutoDAO)
        when: "i use it to manipulate my database"
        def produto = new ProdutoController(mockedDAO).criar("a;b;c;d;e")
        then: "it should return a not null product code"
        !produto.is(null)

    }

    def "should be able to mock dao when calling criar()"() {
        given:"a mocked dao"
        def mockedDAO = Mock(ProdutoDAO)
        when:" I use it to call product creation"
        new ProdutoController(mockedDAO).criar("a;b;c;d;e")
        then: "i should be able to mock responses accordingly, verifying it in the end of the test"
        1 * mockedDAO.buscaPorEAN(_ as String) >> []
        1 * mockedDAO.buscaPorNome(_ as String) >> []
    }

    def "should be able to mock dao exceptions when calling criar() with other syntax"() {
        setup: "mocks which gonna be checked"
        def mockedDAO = Mock(ProdutoDAO) {
            1 * buscaPorEAN("e") >> []
            1 * buscaPorNome("a") >> []
            1 * createProduct("a;b;c;d;e") >> 1
            1 * getProduct(1) >> Mock(Produto)
        }
        when: "creating a product using mocks"
        def produto = new ProdutoController(mockedDAO).criar("a;b;c;d;e")
        then: "it should return a not null product"
        !produto.is(null)

    }
}

</code></pre>
</section>
                    <section data-markdown>
                        whaaat! Caracterizei parte de um lugar que não serviu para o problema em questão
                        Note:
                        explica porque, mostrando os códigos do controller e do DAO
                    </section>
                    <section data-markdown>Que bom!!! testei várias coisas...</section>

				</section>
				<section data-markdown>
                        # Errata:
                        
                        Mas e as metaClasses, e os Traits, Mixins?
				</section>
				<section>
                    <section data-markdown>
                        # Por que Groovy?
                        Note:
                        abre o groovyconsole prá mostrar exemplos
                    </section>
                    <section data-markdown>
                        expressividade
                        Note:
                        o groovy permite que se crie metodos com nome de string. tem assertions embutidas na classe GroovyTestCase alguns parenteses somem, regex operations, keyword assert. assertions bonitonas
                    </section>
                    <section data-markdown>
                        assertividade
                        Note:
                        o groovy permite ignorar detalhes que não interessam. Tipos...retorno de método...try-catch...
                    </section>
                    <section data-markdown>
                        Exceptions
                        Note:
                        shouldFail é d+! tira um monte de coisa do radar. O thrown do Spock, parecido com o do JUnit mas mais bonito, é demais tb
                    </section>
                    <section data-markdown>
                        Test Double
                        Note:
                        vários jeitos de fazer mock. com closure, com map, com framework, com a classe MockFor, com o spock que tem mock embutido
                    </section>
                    <section data-markdown>
                        Spock!
                        Note:
                        escrevendo testes como texto. output é sensacional. a ideia de EXIGIR sections nos testes é sensacional, orienta o pensamento a comportamento. teste naturalmente é uma DSL
                    </section>
                    <section data-markdown>
                        comunicação
                        Note:
                        esse monte de texto que eu posso escrever é melhor que um comentario e aparece lá no report final...e o report do spock é ainda mais sensacional (mostrar reports)
                    </section>
                </section>
                <section data-markdown>
                    ## Em suma...
                    Escrever teste em código legado é como ler um livro surreal e complexo. O Groovy (+Spock) permite tomar notas e fazer observações com mais velocidade, assertividade e abstraindo detalhes não tão importantes do Java
                </section>
            </div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		e<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
